# vim: filetype=perl:softtabstop=4:tabstop=4

# This file is part of LilyPond, the GNU music typesetter.
#
# Copyright (C) 2023--2023 Jonas Hahnfeld <hahnjo@hahnjo.de>
#
# LilyPond is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# LilyPond is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with LilyPond.  If not, see <http://www.gnu.org/licenses/>.

# This file contains LilyPond's customization for the HTML output by texi2any.
# While rewritten from scratch, parts of this file are based on the previous
# lilypond-texi2html.init originally written by Reinhold Kainhofer and modified
# by many others over the years.

package Texinfo::Config;

use strict;

our $texinfo_version = $Texinfo::Common::VERSION;

### Set customization variables.
# Output the Table of Contents into a separate file.
if ($texinfo_version lt '6.8') {
    set_from_init_file('INLINE_CONTENTS', '0');
} elsif ($texinfo_version lt '7.0') {
    set_from_init_file('CONTENTS_OUTPUT_LOCATION', 'separate_element');
} else {
    texinfo_set_from_init_file('CONTENTS_OUTPUT_LOCATION', 'separate_element');
}

# This gives us Texinfo menus as defined in the source.
if ($texinfo_version lt '6.8') {
    set_from_init_file('SHOW_MENU', '1');
} elsif ($texinfo_version lt '7.0') {
    set_from_init_file('FORMAT_MENU', 'menu');
} else {
    texinfo_set_from_init_file('FORMAT_MENU', 'menu');
}

# Remove colon after index (before Texinfo 7.1) and menu entries (Texinfo 6.8
# and later).
if ($texinfo_version lt '7.0') {
    set_from_init_file('INDEX_ENTRY_COLON', '');
    set_from_init_file('MENU_ENTRY_COLON', '');
} else {
    texinfo_set_from_init_file('INDEX_ENTRY_COLON', '');
    texinfo_set_from_init_file('MENU_ENTRY_COLON', '');
}

# Use (translated) section names in the indices, the menus, and in the <title>
# for split output.
if ($texinfo_version lt '7.0') {
    set_from_init_file('USE_NODES', '0');
    set_from_init_file('NODE_NAME_IN_INDEX', '0');
    set_from_init_file('NODE_NAME_IN_MENU', '0');
    set_from_init_file('SECTION_NAME_IN_TITLE', '1');
} else {
    texinfo_set_from_init_file('USE_NODES', '0');
    texinfo_set_from_init_file('NODE_NAME_IN_INDEX', '0');
    texinfo_set_from_init_file('NODE_NAME_IN_MENU', '0');
    texinfo_set_from_init_file('SECTION_NAME_IN_TITLE', '1');
}

# Hide the title heading, which is the default since Texinfo 7.0.
if ($texinfo_version lt '7.0') {
    set_from_init_file('SHOW_TITLE', '0');
}


### Lower-case the node file names and the label target names.
sub lilypond_node_file_name {
    my ($converter, $element, $file_name) = @_;
    return lc($file_name);
}

sub lilypond_label_target_name {
    my ($converter, $normalized, $node_contents, $default_target) = @_;
    if (!defined($default_target)) {
        # In Texinfo 7.0, label_target_name received only three arguments.
        $default_target = $node_contents;
    }
    if (!defined($default_target)) {
        # Before Texinfo 7.0, label_target_name received only two arguments.
        $default_target = $normalized;
    }
    return lc($default_target);
}
if ($texinfo_version lt '7.0') {
    use vars qw($node_file_name $node_target_name);
    $node_file_name = \&lilypond_node_file_name;
    $node_target_name = \&lilypond_label_target_name;
} else {
    texinfo_register_file_id_setting_function('node_file_name',
                                              \&lilypond_node_file_name);
    texinfo_register_file_id_setting_function('label_target_name',
                                              \&lilypond_label_target_name);
}


### Format references, either internal or external.
sub lilypond_format_ref {
    my ($converter, $command_name, $element, $args, $content) = @_;

    my $name;
    if ($args->[2] and defined($args->[2]->{'normal'}) and
        $args->[2]->{'normal'} ne '') {
        $name = $args->[2]->{'normal'};
    } elsif ($args->[1] and defined($args->[1]->{'normal'}) and
             $args->[1]->{'normal'} ne '') {
        $name = $args->[1]->{'normal'};
    }

    my $file = '';
    if ($args->[3]) {
        if ($texinfo_version lt '7.0.90') {
            if (defined($args->[3]->{'monospacetext'}) and
                $args->[3]->{'monospacetext'} ne '') {
                $file = $args->[3]->{'monospacetext'};
            }
        } else {
            if (defined($args->[3]->{'filenametext'}) and
                $args->[3]->{'filenametext'} ne '') {
                $file = $args->[3]->{'filenametext'};
            }
        }
    }

    my $book = '';
    if ($args->[4] and defined($args->[4]->{'normal'})) {
        $book = $args->[4]->{'normal'}
    }

    # Delegate internal references to the default conversion.
    if ($file eq '') {
        if ($texinfo_version lt '7.0') {
            return &{$converter->default_commands_conversion($command_name)}(
                $converter, $command_name, $element, $args, $content);
        } else {
            return &{$converter->default_command_conversion($command_name)}(
                $converter, $command_name, $element, $args, $content);
        }
    }

    # Expect that we only use @ref for external references.
    if ($command_name ne 'ref') {
        my $msg = "used '$command_name' to link to external manual '$file'";
        $converter->line_error($converter, $msg, $element->{'source_info'});
    }

    my $node_content;
    my $node_file;
    if ($texinfo_version lt '7.0.90') {
        if ($element->{'extra'} and $element->{'extra'}->{'node_argument'} and
            $element->{'extra'}->{'node_argument'}->{'node_content'}) {
            $node_content = $element->{'extra'}->{'node_argument'}->{'node_content'};
        }
    } else {
        my $node_arg = $element->{'args'}->[0];
        if ($node_arg->{'extra'} and $node_arg->{'extra'}->{'node_content'}) {
            $node_content = $node_arg->{'extra'}->{'node_content'};
        }
    }

    if (defined($node_content)) {
        $node_file = Texinfo::Convert::NodeNameNormalization::normalize_node(
            {'contents' => $node_content});
        $node_file = lc($node_file);

        if (!defined($name)) {
            my $node_tree = {'type' => '_code', 'contents' => [@$node_content]};
            my $node_name = $converter->convert_tree($node_tree, 'node in ref');
            if (defined($node_name) and $node_name ne 'Top') {
                $name = $node_name;
            }
        }
    } else {
        my $msg = "could not determine node for link to external manual '$file'";
        $converter->line_error($converter, $msg, $element->{'source_info'});
    }

    if (!defined($name)) {
        if ($book eq '') {
            my $msg = "could not determine name for link to external manual '$file'";
            $converter->line_error($converter, $msg, $element->{'source_info'});
        }
        $name = $book;
    }

    my $href;
    if ($converter->get_conf('SPLIT')) {
        if ($node_file eq 'top') {
            $node_file = 'index';
        }
        $href = "../$file/$node_file.html";
    } else {
        # In this case, $file already has the big-page postfix.
        my $target = $node_file;
        $target =~ s/^([0-9_])/g_t$1/;
        $href = "$file.html#$target";
    }

    return "<a href=\"$href\">$name</a>";
}

our $ref_commands;
if ($texinfo_version lt '7.0') {
    $ref_commands = \%Texinfo::Common::ref_commands;
} else {
    $ref_commands = \%Texinfo::Commands::ref_commands;
}
foreach my $command (keys(%$ref_commands)) {
    texinfo_register_command_formatting($command, \&lilypond_format_ref);
}

return 1;
